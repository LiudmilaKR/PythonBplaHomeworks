'''
Шаг 1. Написать код, который может вызвать ошибку (например, деление на ноль)
Шаг 2. Импортировать модуль pdb и добавить вызов pdb.set_trace() перед строкой, где предполагается ошибка.
Шаг 3. Запустить код - при достижении точки останова pdb откроется отладчик. Исследовать текущее состояние 
переменных и шаг за шагом выполнить код до ошибки.
Шаг 4. Добавить блок try/except вокруг опасного кода и перехватывать конкретный тип ошибки.
Шаг 5. В блоке except написать код для обработки исключения - например, вывод сообщения и продолжение работы программы.
Шаг 6. Проверить работу обработки ошибки, запустив код ещё раз. Убедиться, что исключение перехватывается корректно.
Шаг 7. Проверить работу обработки ошибки, запустив код ещё раз. Убедиться, что исключение перехватывается корректно.
Шаг 8. При необходимости добавить блок finally для кода, который должен выполниться в любом случае.
'''

class Actions():
    
    def __init__(self, result=0) -> None:
        self.result = result
    
    def multiply(self, a: int, b: int) -> int:
        self.result = a * b
        print(f'Результат умножения {a=} и {b=} составляет {self.result}')
        return

    def divide(self, a: int, b: int) -> float:
        try:
            self.result = a / b
            print(f'Результат деления {a=} и {b=} составляет {self.result}')
        except ArithmeticError:
            print('Ошибка! Деление на ноль!')
        finally:
            print('Операция произведена')


# import bdb; bdb.set_trace()

# try:
#     print(f'a разделить на b равно {a / b}')
# except ArithmeticError:
#     print('Деление на ноль!')
# finally:
#     print('Операция произведена!')

# if b == 0:
#     raise ArithmeticError('Деление на ноль!')
# else:
#     print(f'a разделить на b равно {a / b}')

# python3 -m bdb task4_mod1_hw.py